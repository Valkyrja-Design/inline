<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Bitwise shift operations with negative operands in C++ - inline</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exploring how C++20 defines bitwise shifts with negative operands"><meta property="og:image" content><meta property="og:url" content="https://valkyrja-design.github.io/inline/posts/cpp_bitwise_shift/"><meta property="og:site_name" content="inline"><meta property="og:title" content="Bitwise shift operations with negative operands in C++"><meta property="og:description" content="Exploring how C++20 defines bitwise shifts with negative operands"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-18T02:20:53+05:30"><meta property="article:modified_time" content="2026-01-18T02:20:53+05:30"><meta property="article:tag" content="C++"><meta property="article:tag" content="Bitwise Operations"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bitwise shift operations with negative operands in C++"><meta name=twitter:description content="Exploring how C++20 defines bitwise shifts with negative operands"><link href=https://valkyrja-design.github.io/inline/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://valkyrja-design.github.io/inline/css/main.a91be01b77f449115ca32bb91f071ef4f25f02998f33b084cb449ded700c062a.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://valkyrja-design.github.io/inline/css/dark.478e7f2b9cf8d87be42edfd9fe1810beab1331847df94b1b430478b309f28282.css disabled><link rel=stylesheet href=https://valkyrja-design.github.io/inline/katex/katex.min.css><script defer src=https://valkyrja-design.github.io/inline/katex/katex.min.js></script><script defer src=https://valkyrja-design.github.io/inline/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><div class=main><a href=https://valkyrja-design.github.io/inline/>inline</a></div><nav><a href=/inline/>Home</a>
<a href=/inline/posts>All posts</a>
<a href=/inline/tags>Tags</a>
<button id=dark-mode-toggle class=nav-toggle onclick=toggleTheme() aria-label="Toggle dark mode" type=button><svg class="feather" viewBox="0 0 24 24" fill="none" stroke="#232333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button>
<script src=https://valkyrja-design.github.io/inline/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Bitwise shift operations with negative operands in C++</h1><div class=meta>Posted on Jan 18, 2026</div></div><section class=body><p>For bitwise operation $lhs \ll rhs$ or $lhs \gg rhs$ in C++, the type of the
result is the type of $lhs$ (after promotions/conversions). The behavior is
undefined if $rhs$ is negative or greater than or equal to the number of bits in
$lhs$. The reason for the latter being that
<a href=https://stackoverflow.com/questions/51145636/why-does-shifting-a-variable-by-more-than-its-width-in-bits-zeroes-out>different CPUs handle shifts greater than bit-width differently</a>.</p><p>Since C++20 wherein <a href=https://stackoverflow.com/questions/57363324/ramifications-of-c20-requiring-twos-complement>signed integers must use two&rsquo;s complement</a>, the behavior for other cases is
defined as follows</p><ul><li>The value of $a \ll b$ is the <em>unique</em> value congruent to $a * 2^{b}$
modulo $2^{n}$, where $n$ is the number of bits in the type of $a$. That is,
bitwise left shift is performed and the bits that get shifted out are
discarded.</li><li>The value of $a \gg b$ is $a / 2^{b}$, rounded towards negative infinity, i.e.,
arithmetic right shift as opposed to logical right shift.</li></ul><p>The results for positive $a$ are not very surprising, but things get weird for
negative $a$. For example,</p><p><a href=https://godbolt.org/z/1sjPh6dh9>See demo on Godbolt</a></p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#include</span> <span style=color:#8b949e;font-weight:700;font-style:italic>&lt;iostream&gt;</span><span style=color:#8b949e;font-weight:700;font-style:italic>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// bit pattern: 10000000&#39;00000000&#39;00000000&#39;00000001
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int32_t</span> a <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>2147483647</span>;
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// bit pattern: 00000000&#39;00000000&#39;00000000&#39;00000010
</span></span></span><span style=display:flex><span>    <span style=color:#ff7b72>int32_t</span> b <span style=color:#ff7b72;font-weight:700>=</span> a <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> <span style=color:#a5d6ff>1</span>; <span style=color:#8b949e;font-style:italic>// Only well-defined from C++20 onwards
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#ff7b72;font-weight:700>::</span>cout <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> b <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> <span style=color:#a5d6ff>&#39;\n&#39;</span>; <span style=color:#8b949e;font-style:italic>// prints 2!
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#ff7b72;font-weight:700>::</span>cout <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> (<span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>5</span> <span style=color:#ff7b72;font-weight:700>&gt;&gt;</span> <span style=color:#a5d6ff>1</span>) <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> <span style=color:#a5d6ff>&#39;\n&#39;</span>; <span style=color:#8b949e;font-style:italic>// -3, rounded towards -infinity
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Before C++20, the behavior of <code>a &lt;&lt; b</code> where <code>a</code> is negative was undefined.</p><p><a href=https://jfbastien.com/>JF Bastien</a>, the author of the paper that proposed two&rsquo;s complement for
C++20 also gave an amazing talk on it: <a href="https://youtu.be/JhUxIVf1qok?si=F2Z4V18_IHqD5caz"><em>Signed Integers are Two&rsquo;s Complement</em></a></p><hr><h2 id=references>References</h2><ul><li><a href=https://en.cppreference.com/w/cpp/language/operator_arithmetic.html>cppreference: Built-in bitwise shift operators</a></li><li><a href=https://stackoverflow.com/questions/51145636/why-does-shifting-a-variable-by-more-than-its-width-in-bits-zeroes-out>StackOverflow: Why does shifting a variable by more than its width in bits zeroes out?</a></li><li><a href=https://stackoverflow.com/questions/57363324/ramifications-of-c20-requiring-twos-complement>StackOverflow: Ramifications of C++20 requiring two&rsquo;s complement</a></li><li><a href="https://youtu.be/JhUxIVf1qok?si=F2Z4V18_IHqD5caz">YouTube: Signed Integers are Two&rsquo;s Complement</a></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/c++>C++</a></li><li><a href=/tags/bitwise-operations>Bitwise Operations</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/Valkyrja-Design rel=me title=GitHub><svg class="feather"><use href="/inline/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a></div><div class=footer-info>2026 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>