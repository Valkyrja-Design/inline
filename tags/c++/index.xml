<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on inline</title><link>https://valkyrja-design.github.io/inline/tags/c++/</link><description>Recent content in C++ on inline</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 18 Jan 2026 02:20:53 +0530</lastBuildDate><atom:link href="https://valkyrja-design.github.io/inline/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Bitwise shift operations with negative operands in C++</title><link>https://valkyrja-design.github.io/inline/posts/cpp_bitwise_shift/</link><pubDate>Sun, 18 Jan 2026 02:20:53 +0530</pubDate><guid>https://valkyrja-design.github.io/inline/posts/cpp_bitwise_shift/</guid><description>&lt;p&gt;For bitwise operation $lhs \ll rhs$ or $lhs \gg rhs$ in C++, the type of the
result is the type of $lhs$ (after promotions/conversions). The behavior is
undefined if $rhs$ is negative or greater than or equal to the number of bits in
$lhs$. The reason for the latter being that
&lt;a href="https://stackoverflow.com/questions/51145636/why-does-shifting-a-variable-by-more-than-its-width-in-bits-zeroes-out"&gt;different CPUs handle shifts greater than bit-width differently&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since C++20 wherein &lt;a href="https://stackoverflow.com/questions/57363324/ramifications-of-c20-requiring-twos-complement"&gt;signed integers must use two&amp;rsquo;s complement&lt;/a&gt;, the behavior for other cases is
defined as follows&lt;/p&gt;</description></item><item><title>Subnormal numbers</title><link>https://valkyrja-design.github.io/inline/posts/subnormals/</link><pubDate>Mon, 12 Jan 2026 02:34:00 +0530</pubDate><guid>https://valkyrja-design.github.io/inline/posts/subnormals/</guid><description>&lt;p&gt;Floating-point numbers represented using the usual
&lt;a href="https://en.wikipedia.org/wiki/IEEE_754"&gt;IEEE 754&lt;/a&gt; use the following format for
a 32-bit &lt;code&gt;float&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 bit: sign&lt;/li&gt;
&lt;li&gt;8 bits: exponent&lt;/li&gt;
&lt;li&gt;23 bits: fraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="images/float_repr.png" alt="float_repr"&gt;&lt;/p&gt;
&lt;p&gt;Exponent 0 is reserved for representing subnormal numbers and zero and exponent
255 is reserved for representing infinity and NaN.&lt;/p&gt;
&lt;p&gt;Normalized numbers always have the leading bit as 1 (&lt;code&gt;1.xxxxxx * 2^exp&lt;/code&gt;). This
means that the smallest normalized positive float is &lt;code&gt;1.0 * 2^-126&lt;/code&gt; and we end
up missing smaller numbers closer to zero. Without subnormals, values very near
zero would abruptly underflow to zero, which may not be desirable for high
precision calculations.&lt;/p&gt;</description></item><item><title>std::unordered_map: emplace vs try_emplace</title><link>https://valkyrja-design.github.io/inline/posts/emplace_vs_try_emplace/</link><pubDate>Sat, 27 Dec 2025 19:42:03 +0530</pubDate><guid>https://valkyrja-design.github.io/inline/posts/emplace_vs_try_emplace/</guid><description>&lt;p&gt;&lt;code&gt;std::unordered_map&lt;/code&gt; provides 3 primary methods for inserting elements with each differing in how
the key and value type are constructed and inserted. &lt;code&gt;insert&lt;/code&gt; is mostly the same as &lt;code&gt;emplace&lt;/code&gt; except
when called with an object of the map&amp;rsquo;s value type directly.&lt;/p&gt;
&lt;h2 id="emplace"&gt;&lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map/emplace.html"&gt;&lt;code&gt;emplace&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;emplace&lt;/code&gt; constructs the key and value in place using the provided arguments. This means that
even if the key is immovable and non-copyable &lt;code&gt;emplace&lt;/code&gt; still works. The downside of emplace is that
the value object is always constructed even if the key already exists in the map.&lt;/p&gt;</description></item></channel></rss>