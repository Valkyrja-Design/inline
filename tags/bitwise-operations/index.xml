<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bitwise Operations on inline</title><link>https://valkyrja-design.github.io/inline/tags/bitwise-operations/</link><description>Recent content in Bitwise Operations on inline</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 18 Jan 2026 02:20:53 +0530</lastBuildDate><atom:link href="https://valkyrja-design.github.io/inline/tags/bitwise-operations/index.xml" rel="self" type="application/rss+xml"/><item><title>Bitwise shift operations with negative operands in C++</title><link>https://valkyrja-design.github.io/inline/posts/cpp_bitwise_shift/</link><pubDate>Sun, 18 Jan 2026 02:20:53 +0530</pubDate><guid>https://valkyrja-design.github.io/inline/posts/cpp_bitwise_shift/</guid><description>&lt;p&gt;For bitwise operation $lhs \ll rhs$ or $lhs \gg rhs$ in C++, the type of the
result is the type of $lhs$ (after promotions/conversions). The behavior is
undefined if $rhs$ is negative or greater than or equal to the number of bits in
$lhs$. The reason for the latter being that
&lt;a href="https://stackoverflow.com/questions/51145636/why-does-shifting-a-variable-by-more-than-its-width-in-bits-zeroes-out"&gt;different CPUs handle shifts greater than bit-width differently&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since C++20 wherein &lt;a href="https://stackoverflow.com/questions/57363324/ramifications-of-c20-requiring-twos-complement"&gt;signed integers must use two&amp;rsquo;s complement&lt;/a&gt;, the behavior for other cases is
defined as follows&lt;/p&gt;</description></item></channel></rss>